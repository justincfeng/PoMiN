var documenterSearchIndex = {"docs":
[{"location":"hamlsb.html#LSB-Hamiltonian","page":"Hamlsb","title":"LSB Hamiltonian","text":"","category":"section"},{"location":"hamlsb.html#Locator-function-selector","page":"Hamlsb","title":"Locator function selector","text":"","category":"section"},{"location":"hamlsb.html","page":"Hamlsb","title":"Hamlsb","text":"pomin.psf","category":"page"},{"location":"hamlsb.html#pomin.psf","page":"Hamlsb","title":"pomin.psf","text":"psf( p::RealVec )\n\nMomentum squared function\n\n\n\n\n\n","category":"function"},{"location":"hamlsb.html#Examples","page":"Hamlsb","title":"Examples","text":"","category":"section"},{"location":"hamlsb.html#Matrix","page":"Hamlsb","title":"Matrix","text":"","category":"section"},{"location":"hamlsb.html","page":"Hamlsb","title":"Hamlsb","text":"Matrix equation for M:","category":"page"},{"location":"hamlsb.html","page":"Hamlsb","title":"Hamlsb","text":"mathcalM = 2\n  left\n  beginarraycccc\n    t_1-t_2    x_2-x_1    y_2-y_1    z_2-z_1 \n    t_2-t_3    x_3-x_2    y_3-y_2    z_3-z_2 \n    t_3-t_4    x_4-x_3    y_4-y_3    z_4-z_3 \n    t_4-t_5    x_5-x_4    y_5-y_4    z_5-z_4 \n  endarray\n  right ","category":"page"},{"location":"index.html#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Relativistic positioning refers to the concept of establishing spacetime positions from proper time broadcasts emitted by a system of satellites. Central to relativistic positioning is the relativistic location location problem, which is the problem of finding the intersection of future pointing light cones from a collection of at least four emission points. cereal.jl contains a collection of functions for the relativistic location problem in flat spacetime.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The name cereal is derived from an attempted pronounciation of the  acronym SRL for Special Relativistic Locator.","category":"page"},{"location":"index.html#Short-tutorial","page":"Home","title":"Short tutorial","text":"","category":"section"},{"location":"index.html#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The cereal.jl code was written for and tested in Julia 1.6; we recommend Julia 1.6 or newer–-please refer to the installation instructions here. To add cereal.jl as a package in Julia, open the Julia REPL, then open the the package manager by typing ]. In the package manager, run the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pkg> add https://github.com/justincfeng/cereal.jl/","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The package manager can be exited by pressing the backspace key. Once  added, one may access the cereal module with the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using cereal","category":"page"},{"location":"index.html#Relativistic-locator","page":"Home","title":"Relativistic locator","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To run the cereal code, one begins by generating a set of emission points with the following:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ( X , Xtar ) = cereal.ceval.pgen(Float64,5)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The quantity Xtar is a four component vector representing the true intersection point, and X is a 45 matrix consisting set of 4 column vectors representing the coordinates of the emission points. The emission points are constructed by finding points on the past light cone of the target point Xtar.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Three different methods for finding the intersection point have been implemented, which are represented by the strings CFM10, FHC22 and RTC21. The method RTC21 (see reference below) is recommended, but requires at least five emission points. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To select the locator function associated with the method RTC21, use the cereal.locatorselect function, which outputs the appropriate locator function:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> locator = cereal.locatorselect(5,\"RTC21\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The first argument is the number of emission points; for the method RTC21, the value should be at least 5 (larger values yield functions which take additional points into consideration). Once the locator function is selected, one may feed the emission point matrix X into the locator function to obtain the intersection point Xc:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Xc = locator(X)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The intersection point may then be compared with Xtar:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Xc - Xtar","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In most cases, the differences in the components should be on the order of the machine precision (10^-15 for the default floating point type Float64).","category":"page"},{"location":"index.html#Other-methods","page":"Home","title":"Other methods","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The methods CFM10, FHC22 are four-point methods, the first argument of cereal.locatorselect can have a value of at least 4. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To try out the method CFM10, one may use the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> locator4a = cereal.locatorselect(4,\"CFM10\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To try out the method FHC22, use:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> locator4b = cereal.locatorselect(4,\"FHC22\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Since four-point methods generally suffer from the bifurcation problem (see Coll et al., Phys. Rev. D 86, 084036 (2012)), these locator functions return a tuple of points. It should be mentioned that if one feeds 45 matrix X, the functions locator4a and locator4b only use the first four emission points.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Xca = locator4a(X)\n\njulia> Xcb = locator4b(X)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the tuple Xca, either Xca[1] or Xca[2] should be close to the point Xtar.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If one increases the number of emission points, then the resulting functions take additional emission points into consideration for the purpose of minimizing errors and avoiding the bifurcation problem:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> locator5a = cereal.locatorselect(5,\"CFM10\")\n\njulia> locator5b = cereal.locatorselect(5,\"FHC22\")","category":"page"},{"location":"index.html#Evaluation","page":"Home","title":"Evaluation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Routines have been written to evaluate the methods more comprehensively. The function cereal.ceval.main(locator,N,q,ne) takes a locator function locator generates N sets of ne emission points X on the past light cone of target points Xtar, feeds each set into locator, and checks that locator yields results Xc that differ from Xtar by a factor less than a threshold value q. One may run the following:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> cereal.ceval.main(cereal.locatorselect(4,\"CFM10\"),100000,1e-6,4)\n\njulia> cereal.ceval.main(cereal.locatorselect(4,\"FHC22\"),100000,1e-6,4)\n\njulia> cereal.ceval.main(cereal.locatorselect(5,\"RTC21\"),100000,1e-9,5)\n\njulia> cereal.ceval.main(cereal.locatorselect(6,\"RTC21\"),100000,5e-13,6)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"One should encounter less than 10 failures in each case.","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CFM10: Coll, B. and Ferrando, J. J. and Morales-Lladosa, J. A., Positioning Systems in Minkowski Space-Time: from Emission to Inertial Coordinates, Class. Quant. Grav. 27, 065013 (2010)   doi:10.1088/0264-9381/27/6/065013 [arXiv:0910.2568]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"RTC21: Ruggiero, M. L., Tartaglia, A., Casalino, L., Geometric approach to the definition of emission coordinates, (2021)   [arXiv:2111.13423]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FHC22: Feng, J. C., Hejda, F., Carloni, S., Relativistic location algorithm in curved spacetime, (2022) [arXiv:2201.01774]","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use cereal.jl in your work, please cite the FHC22 paper (and the CFM10 and RTC21 papers above if you have employed those methods):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{Feng2022relloc,\n    author = \"Feng, Justin C. and Hejda, Filip and Carloni, Sante\",\n    title = \"{Relativistic location algorithm in curved spacetime}\",\n    eprint = \"2201.01774\",\n    archivePrefix = \"arXiv\",\n    primaryClass = \"gr-qc\",\n    month = \"1\",\n    year = \"2022\"\n}","category":"page"},{"location":"integrators.html#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"integrators.html","page":"Integrators","title":"Integrators","text":"The integrators used in PoMiN","category":"page"},{"location":"integrators.html#RK4-Integrator","page":"Integrators","title":"RK4 Integrator","text":"","category":"section"},{"location":"integrators.html","page":"Integrators","title":"Integrators","text":"pomin.Jsympl","category":"page"},{"location":"integrators.html#pomin.Jsympl","page":"Integrators","title":"pomin.Jsympl","text":"Jsympl( Zarg::RealVec )\n\nSymplectic operator hatJ.  Takes vector vecz and returns hatJvecz where  hatJ = beginbmatrix 0  I  -I  0 endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"integrators.html","page":"Integrators","title":"Integrators","text":"pomin.hrkintegrator","category":"page"},{"location":"integrators.html#pomin.hrkintegrator","page":"Integrators","title":"pomin.hrkintegrator","text":"hrkintegrator( z0::RealVec, dH::Function , δ::Real \n                , tadap::Function , tspan::Tuple{Real,Real} , maxit::Real )\n\n4th order Runge-Kutta integrator\n\nArguments\n\nz0::RealVec: Initial values phase space vector  vecq vecp \ndH::Function: Gradient of the Hamiltonian with respect to the phase space vector vecz.  Takes a single parameter veczi of the values of the phase space variables at the current time and returns a the gradient of H which is a vector with the same dimensionality as veczi\nδ::Real: Time step to be used by the integrator\ntadap::Function: Adaptive time-stepping function.  Takes a single parameter veczi of the values of the phase space variables at the current time and returns the time step\ntspan::Tuple{Real,Real}: Tuple containing the start time and end time for the integration\nmaxit::Real: Maximum number of iterations.  When this number of iterations is exceeded, integration stops.\n\n\n\n\n\n","category":"function"},{"location":"integrators.html#Tao-Symplectic-Integrator","page":"Integrators","title":"Tao Symplectic Integrator","text":"","category":"section"},{"location":"integrators.html","page":"Integrators","title":"Integrators","text":"pomin.hsintegrator","category":"page"},{"location":"integrators.html#pomin.hsintegrator","page":"Integrators","title":"pomin.hsintegrator","text":"hsintegrator( z0::RealVec, dH::Function , δ::Real , ω::Real , tspan::Tuple{Real,Real} , maxit::Real )\n\nSymplectic integrator of Tao\n\nArguments\n\nz0::RealVec: Initial values of phase space vector  vecq vecp \ndH::Function: Gradient of the Hamiltonian with respect to the phase space vector vecz.  Takes a single parameter veczi of the values of the phase space variables at the current time and returns a the gradient of H which is a vector with the same dimensionality as veczi\nδ::Real: Time step to be used by the integrator\nω::Real: Parameter needed for Tao's method of integration.  See arXiv:1609.02212\ntspan::Tuple{Real,Real}: Tuple containing the start time and end time for the integration\nmaxit::Real: Maximum number of iterations.  When this number of iterations is exceeded, integration stops.\n\n\n\n\n\n","category":"function"}]
}
